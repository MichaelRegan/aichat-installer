#!/usr/bin/env bash
#  aichat-install.sh
#  Download and install aichat from GitHub releases
#
#  Usage:
#     ./install-aichat [version|latest]
#     AICHAT_VERSION=[version|latest] ./install-aichat
#     AICHAT_VERSION=[version|latest] curl -fsSL <url> | bash
#
#  Examples:
#     ./install-aichat                 # Auto-detects latest version (interactive)
#     ./install-aichat latest          # Uses latest version
#     ./install-aichat 0.30.0          # Uses specific version
#     AICHAT_VERSION=latest curl -fsSL https://raw.githubusercontent.com/MichaelRegan/aichat-installer/main/install-aichat | bash
#     curl -fsSL https://raw.githubusercontent.com/MichaelRegan/aichat-installer/main/install-aichat | bash  # Auto-detects latest
#
#  The script automatically asks for sudo when needed.

set -euo pipefail
IFS=$'\n\t'  # make read -r safer; useful for filenames with spaces

# ------------------------------------------------------------------
# Non-interactive / automation controls
# ------------------------------------------------------------------
# If AICHAT_ASSUME_YES=1 is set in the environment, all prompts that would
# normally require user confirmation will auto-accept the default affirmative
# choice (proceed, install, overwrite, etc.). This is useful for CI or when
# piping the script via curl without wanting to rely on `yes |` which can
# trigger SIGPIPE with `set -o pipefail`.
AICHAT_ASSUME_YES="${AICHAT_ASSUME_YES:-0}"
# Dry run mode (no filesystem writes); can be enabled via env AICHAT_DRY_RUN=1 or --dry-run / -n flag
AICHAT_DRY_RUN="${AICHAT_DRY_RUN:-0}"
AICHAT_JSON="${AICHAT_JSON:-0}"           # When set with dry-run, output machine-readable JSON plan
AICHAT_NO_WRAPPER="${AICHAT_NO_WRAPPER:-0}" # Skip creating wrapper (keep binary as aichat)
AICHAT_SKIP_ROLE="${AICHAT_SKIP_ROLE:-0}"   # Skip installing gen-aichat-role & role config

# Parse global flags (currently only --dry-run / -n). Remove them from $@ so version arg still works.
if [[ $# -gt 0 ]]; then
    _new_args=()
    for _arg in "$@"; do
        case "$_arg" in
            --dry-run|-n)
                AICHAT_DRY_RUN=1 ;;
            --json)
                AICHAT_JSON=1 ;;
            --no-wrapper)
                AICHAT_NO_WRAPPER=1 ;;
            --skip-role)
                AICHAT_SKIP_ROLE=1 ;;
            *)
                _new_args+=("$_arg")
                ;;
        esac
    done
    set -- "${_new_args[@]}"
fi

# In dry-run mode force assume-yes to avoid interactive prompts
if [[ "$AICHAT_DRY_RUN" == "1" ]]; then AICHAT_ASSUME_YES=1; fi

assume_yes() { [[ "${AICHAT_ASSUME_YES}" == "1" ]]; }

prompt_yes_no() {
    # Usage: prompt_yes_no <default_y|n> <question>
    local default_ans="$1"; shift
    local question="$*"
    if assume_yes; then
        # Always accept the affirmative path; if default is no we still force yes.
        echo "$question" >&2
        echo "(auto-yes due to AICHAT_ASSUME_YES=1)" >&2
        return 0
    fi
    local prompt
    if [[ "$default_ans" == "y" ]]; then
        prompt="(Y/n)";
    else
        prompt="(y/N)";
    fi
    echo -n "$question $prompt: "
    read -r reply || reply=""
    if [[ -z "$reply" ]]; then
        [[ "$default_ans" == "y" ]]
    else
        [[ "$reply" =~ ^[Yy]$ ]]
    fi
}

# ------------------------------------------------------------------
# Helper functions
# ------------------------------------------------------------------

# Validate version format (basic semver pattern)
validate_version() {
    local version="$1"
    if [[ ! $version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "‚ùå Invalid version format. Expected format: X.Y.Z (e.g., 0.30.0)"
        return 1
    fi
    return 0
}

# Detect system architecture
detect_architecture() {
    local arch
    arch=$(uname -m)
    case "$arch" in
        x86_64|amd64)
            echo "linux-x86_64"
            ;;
        aarch64|arm64)
            echo "linux-aarch64"
            ;;
        armv7l)
            echo "linux-armv7"
            ;;
        *)
            echo "‚ùå Unsupported architecture: $arch"
            return 1
            ;;
    esac
}

# Get latest release version from GitHub API
get_latest_version() {
    local latest_url="https://api.github.com/repos/sigoden/aichat/releases/latest"
    local version
    
    # Show progress to stderr so it doesn't interfere with version output
    echo "üîç Fetching latest aichat release..." >&2
    
    # Try to get version from GitHub API
    if command -v curl >/dev/null 2>&1; then
        version=$(curl -fsSL "$latest_url" | grep '"tag_name":' | sed -E 's/.*"tag_name": *"v?([^"]+)".*/\1/' 2>/dev/null)
    elif command -v wget >/dev/null 2>&1; then
        version=$(wget -qO- "$latest_url" | grep '"tag_name":' | sed -E 's/.*"tag_name": *"v?([^"]+)".*/\1/' 2>/dev/null)
    fi
    
    # Validate the version format and return only the version
    if [[ -n "$version" ]] && validate_version "$version"; then
        echo "$version"
        return 0
    else
        echo "‚ùå Failed to fetch latest version from GitHub API" >&2
        return 1
    fi
}

# Check if aichat is already installed
check_existing_installation() {
    if command -v aichat >/dev/null 2>&1; then
        local current_version
        current_version=$(aichat --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "unknown")
        echo "‚ìò aichat is already installed (version: $current_version)"
        if assume_yes; then
            echo "(auto-yes) Proceeding with installation/update due to AICHAT_ASSUME_YES=1"
        else
            echo "Do you want to continue with installation/update? (y/N):"
            read -r response
            if [[ ! $response =~ ^[Yy]$ ]]; then
                echo "‚ìò Skipping binary installation/update."
                SKIP_BINARY_INSTALL=true
                return 0
            fi
        fi
    fi
    SKIP_BINARY_INSTALL=false
}

# Detect current shell
detect_shell() {
    # Prefer the SHELL environment variable as it indicates the user's default shell.
    if [[ -n "${SHELL:-}" ]]; then
        basename "$SHELL"
        return 0
    fi
    
    # Fallback to checking the parent process of the script
    local parent_shell
    parent_shell=$(ps -p $PPID -o comm= 2>/dev/null | tr -d '-')
    if [[ -n "$parent_shell" && "$parent_shell" != "unknown" ]]; then
        echo "$parent_shell"
        return 0
    fi
    
    echo "unknown"
}

# Install shell integration
install_shell_integration() {
    local shell_type="$1"
    local integration_url="https://raw.githubusercontent.com/sigoden/aichat/refs/heads/main/scripts/shell-integration/integration.$shell_type"
    
    echo "üîó Installing shell integration for $shell_type..."
    
    # Download integration script
    local integration_content
    if ! integration_content=$(curl -fsSL "$integration_url"); then
        echo "‚ö†Ô∏è  Failed to download shell integration for $shell_type"
        return 1
    fi
    
    # Determine config file location
    local config_file
    case "$shell_type" in
        bash)
            config_file="$HOME/.bashrc"
            ;;
        zsh)
            config_file="$HOME/.zshrc"
            ;;
        fish)
            config_file="$HOME/.config/fish/config.fish"
            # Create fish config directory if it doesn't exist
            mkdir -p "$(dirname "$config_file")"
            ;;
        *)
            echo "‚ö†Ô∏è  Unsupported shell for integration: $shell_type"
            return 1
            ;;
    esac
    
    # Check if integration is already installed
    if [[ -f "$config_file" ]] && grep -q "aichat.*integration\|_aichat_" "$config_file" 2>/dev/null; then
        echo "‚ìò Shell integration appears to already be installed in $config_file"
        if assume_yes; then
            echo "(auto-yes) Reinstalling integration due to AICHAT_ASSUME_YES=1"
        else
            echo "Do you want to reinstall it? (y/N):"
            read -r response
            if [[ ! $response =~ ^[Yy]$ ]]; then
                return 0
            fi
        fi
        # Remove existing integration
        if command -v sed >/dev/null 2>&1; then
            # Create backup
            cp "$config_file" "$config_file.backup.$(date +%s)"
            # Remove existing aichat integration lines
            sed -i '/# aichat shell integration/,/^$/d' "$config_file" 2>/dev/null || true
            sed -i '/_aichat_/d' "$config_file" 2>/dev/null || true
            sed -i '/bind.*aichat/d' "$config_file" 2>/dev/null || true
            sed -i '/bindkey.*aichat/d' "$config_file" 2>/dev/null || true
        fi
    fi
    
    # Add integration to config file
    {
        echo ""
        echo "# aichat shell integration (installed $(date))"
        echo "$integration_content"
        if [[ "$shell_type" == "zsh" ]]; then
            echo ""
            echo "# Ensure Alt+E works for aichat"
            echo "autoload -U _aichat_zsh"
            echo "zle -N _aichat_zsh"
            echo "bindkey '\eE' _aichat_zsh"
            echo "bindkey '\ee' _aichat_zsh"
        fi
        echo ""
    } >> "$config_file"
    
    echo "‚úÖ Shell integration installed in $config_file"
    echo "   Press Alt+E (or Esc+E) in your terminal to enhance commands with AI"
    echo "   Restart your shell or run 'source $config_file' to activate"
    
    return 0
}

# Ensure aichat configuration directories exist
ensure_aichat_config_dirs() {
    local config_dir="$HOME/.config/aichat"
    local roles_dir="$config_dir/roles"
    
    echo "üìÅ Ensuring aichat configuration directories exist..."
    
    if [[ ! -d "$config_dir" ]]; then
        echo "   Creating config directory: $config_dir"
        mkdir -p "$config_dir" || {
            echo "‚ö†Ô∏è  Failed to create aichat config directory"
            return 1
        }
    fi
    
    if [[ ! -d "$roles_dir" ]]; then
        echo "   Creating roles directory: $roles_dir"
        mkdir -p "$roles_dir" || {
            echo "‚ö†Ô∏è  Failed to create aichat roles directory"
            return 1
        }
    fi
    
    # Set appropriate permissions
    chmod 755 "$config_dir"
    chmod 755 "$roles_dir"
    
    echo "‚úÖ aichat configuration directories ready"
    return 0
}

# Configure aichat to use local role by default
configure_local_role_default() {
    local config_file="$HOME/.config/aichat/config.yaml"
    
    echo "‚öôÔ∏è  Configuring aichat to use local role by default..."
    
    # Create config file if it doesn't exist
    if [[ ! -f "$config_file" ]]; then
        echo "üìù Creating new aichat config file..."
        cat > "$config_file" <<'EOF'
# see https://github.com/sigoden/aichat/blob/main/config.example.yaml

model: gpt-4o-mini
stream: true
editor: nano
keybindings: emacs

# Uncomment and configure if using Ollama
# clients:
# - type: openai-compatible
#   name: ollama
#   api_base: http://localhost:11434/v1
#   api_key: none
#   models:
#   - name: embeddinggemma:300m
#     type: embedding
#     default_chunk_size: 1000
#     max_batch_size: 100
#   - name: Qwen3-Reranker-8B:Q4_K_M
#     type: reranker
#   - name: llama3.2:3b
#     supports_vision: false
#     supports_function_calling: true

# Visit https://github.com/sigoden/llm-functions for setup instructions
function_calling: true           # Enables or disables function calling (Globally).
mapping_tools:                   # Alias for a tool or toolset
  fs: 'fs_cat,fs_ls,fs_mkdir,fs_rm,fs_write'
use_tools: null                  # Which tools to use by default

# Controls the persistence of the session. if true, auto save; if false, not save; if null, asking the user
save_session: null
# Compress session when token count reaches or exceeds this threshold
compress_threshold: 4000
# Text prompt used for creating a concise summary of session message
summarize_prompt: '...'
# Text prompt used for including the summary of the entire session
summary_prompt: '...'

highlight: true                  # Controls syntax highlighting
theme: null                      # Color theme (possible value: dark/light)
# Custom REPL prompt, see https://github.com/sigoden/aichat/wiki/Custom-REPL-Prompt for more details
left_prompt: '...'
right_prompt: '...'

serve_addr: 127.0.0.1:8000                  # Serve listening address 
user_agent: null                            # Set User-Agent HTTP header, use `auto` for aichat/<current-version>
save_shell_history: true                    # Whether to save shell execution command to the history file
#sync_models_url: <url>                      # URL to sync model changes from

# Start the REPL and one-shot CLI in the "local" role by default
repl_prelude: "role:local"
cmd_prelude:  "role:local"
EOF
        chmod 644 "$config_file"
        echo "‚úÖ Config file created with comprehensive default settings"
        echo "   üìã Features enabled: Function calling, shell history, local role"
        echo "   üîß Edit ~/.config/aichat/config.yaml to customize further"
        echo "   üí° Uncomment Ollama section if using local models"
        return 0
    fi
    
    # Check if preludes are already configured
    if grep -q "repl_prelude.*role:local" "$config_file" && grep -q "cmd_prelude.*role:local" "$config_file"; then
        echo "‚ÑπÔ∏è  Local role already configured as default"
        return 0
    fi
    
    # Create backup of existing config
    cp "$config_file" "$config_file.backup.$(date +%s)"
    echo "üìã Backup created: $config_file.backup.$(date +%s)"
    
    # Remove existing prelude configurations if present
    sed -i '/^repl_prelude:/d' "$config_file"
    sed -i '/^cmd_prelude:/d' "$config_file"
    
    # Add the local role configuration
    cat >> "$config_file" <<EOF

# Start the REPL and one-shot CLI in the "local" role by default
# Added by install-aichat script
repl_prelude: "role:local"
cmd_prelude:  "role:local"
EOF
    
    echo "‚úÖ Config updated to use local role by default"
    echo "   REPL mode: Will start with local role context"
    echo "   CLI mode: Will use local role for one-shot commands"
    
    return 0
}

# Test if shell integration is working
test_shell_integration() {
    echo "üß™ Testing shell integration..."
    
    local shell_type="$1"
    case "$shell_type" in
        zsh)
            if command -v zsh >/dev/null 2>&1; then
                echo -n "   zsh integration: "
                if zsh -c 'source ~/.zshrc 2>/dev/null && which _aichat_zsh' >/dev/null 2>&1; then
                    echo "‚úÖ loaded"
                    echo "   üìù Test: Type a command, then press Alt+E (or Esc+E) to enhance it"
                    echo "   üìù Example: Type 'list files' then Alt+E ‚Üí becomes 'ls' or 'find' command"
                    echo "   üß™ Quick test: aichat -e 'show current directory' ‚Üí $(aichat -e 'show current directory' 2>/dev/null | head -1 || echo 'pwd')"
                else
                    echo "‚ùå not loaded"
                fi
            fi
            ;;
        bash)
            if command -v bash >/dev/null 2>&1; then
                echo -n "   bash integration: "
                if grep -q "_aichat_bash" ~/.bashrc 2>/dev/null; then
                    echo "‚úÖ installed"
                    echo "   üìù Test: Type a command, then press Alt+E (or Esc+E) to enhance it"
                    echo "   üìù To activate: start a new bash session or run 'source ~/.bashrc'"
                else
                    echo "‚ùå not installed"
                fi
            fi
            ;;
        fish)
            if command -v fish >/dev/null 2>&1; then
                echo -n "   fish integration: "
                if fish -c 'functions -q _aichat_fish' >/dev/null 2>&1; then
                    echo "‚úÖ loaded"
                    echo "   üìù Test: Type a command, then press Alt+E (or Esc+E) to enhance it"
                else
                    echo "‚ùå not loaded"
                fi
            fi
            ;;
        *)
            echo "   ‚ö†Ô∏è  Shell integration testing not supported for: $shell_type"
            ;;
    esac
}

# Test if completions are working
test_completions() {
    echo "üß™ Testing completions..."
    
    # Test zsh completion
    if command -v zsh >/dev/null 2>&1; then
        echo -n "   zsh: "
        if zsh -c 'autoload -U compinit; compinit; which _aichat' >/dev/null 2>&1; then
            echo "‚úÖ available"
        else
            echo "‚ùå not loaded"
        fi
    fi
    
    # Test bash completion
    if command -v bash >/dev/null 2>&1; then
        echo -n "   bash: "
        if bash -c 'source /usr/share/bash-completion/bash_completion 2>/dev/null && source /usr/share/bash-completion/completions/aichat 2>/dev/null && complete -p aichat' >/dev/null 2>&1; then
            echo "‚úÖ available"
        else
            echo "‚ùå not loaded"
        fi
    fi
    
    # Test fish completion
    if command -v fish >/dev/null 2>&1; then
        echo -n "   fish: "
        if [[ -f "/usr/share/fish/vendor_completions.d/aichat.fish" || -f "$HOME/.config/fish/completions/aichat.fish" ]]; then
            echo "‚úÖ available"
        else
            echo "‚ùå not installed"
        fi
    fi
}

# ------------------------------------------------------------------
# Main execution logic
# ------------------------------------------------------------------
main() {
    # If we are in JSON dry-run mode, redirect all normal stdout chatter to stderr so that
    # the ONLY thing printed to stdout is the final JSON plan object. We restore stdout
    # immediately before emitting the JSON. This makes machine parsing trivial and removes
    # the need for fragile filtering in tests / CI pipelines.
    if [[ "${AICHAT_DRY_RUN}" == "1" && "${AICHAT_JSON}" == "1" && -z "${AICHAT_JSON_STDOUT_REDIRECTED:-}" ]]; then
        AICHAT_JSON_STDOUT_REDIRECTED=1
        exec 3>&1            # save original stdout on FD 3
        exec 1>&2            # send subsequent stdout messages to stderr
    fi
    # ------------------------------------------------------------------
    # 1. Resolve parameters
    # ------------------------------------------------------------------
if [[ $# -eq 0 ]]; then
    # Check for environment variable first (useful for piped installs)
    if [[ -n "${AICHAT_VERSION:-}" ]]; then
        if [[ "${AICHAT_VERSION}" == "latest" ]]; then
            if VERSION=$(get_latest_version); then
                echo "‚úÖ Using latest version: $VERSION"
            else
                echo "‚ùå Failed to fetch latest version"
                exit 1
            fi
        else
            VERSION="$AICHAT_VERSION"
            echo "Using version from AICHAT_VERSION: $VERSION"
        fi
    else
        # Try to get latest version automatically
        if VERSION=$(get_latest_version); then
            echo "‚úÖ Auto-detected latest version: $VERSION"
            
            # Check if we're in a non-interactive environment (like piped from curl)
            if [[ ! -t 0 ]]; then
                echo "Non-interactive mode detected, proceeding with version $VERSION"
            else
                echo "Press Enter to install $VERSION, or specify a different version:"
                if assume_yes; then
                    echo "(auto) Using auto-detected version: $VERSION"
                else
                    read -r user_input
                    if [[ -n "$user_input" ]]; then
                        VERSION="$user_input"
                        echo "Using specified version: $VERSION"
                    else
                        echo "Using auto-detected version: $VERSION"
                    fi
                fi
            fi
        else
            echo "Enter the aichat release version (e.g. 0.30.0):"
            if assume_yes; then
                echo "(auto-fail) Cannot auto-select version without latest; please set AICHAT_VERSION or provide argument." >&2
                exit 1
            else
                read -r VERSION
                if [[ -z $VERSION ]]; then
                    echo "‚ùå No version supplied."
                    echo "üí° Tip: For non-interactive installs, use: curl ... | bash (auto-detects latest)"
                    exit 1
                fi
            fi
        fi
    fi
else
    if [[ "$1" == "latest" ]]; then
        if VERSION=$(get_latest_version); then
            echo "‚úÖ Using latest version: $VERSION"
        else
            echo "‚ùå Failed to fetch latest version"
            exit 1
        fi
    else
        VERSION="$1"
    fi
fi

# Validate version format
if ! validate_version "$VERSION"; then
    exit 1
fi

# Check for existing installation
check_existing_installation

# Detect shell (always needed for completions)
DETECTED_SHELL=$(detect_shell)
echo "‚ìò Detected shell: $DETECTED_SHELL"

# Ask about shell integration
echo "Do you want to install shell integration? This allows you to enhance"
echo "commands with AI by pressing Alt+E (or Esc+E) in your terminal. (Y/n):"
if assume_yes; then
    INSTALL_INTEGRATION=true
    echo "(auto-yes) Enabling shell integration for $DETECTED_SHELL"
else
    read -r install_integration || install_integration=""
    if [[ ! $install_integration =~ ^[Nn]$ ]]; then
        INSTALL_INTEGRATION=true
        if [[ "$DETECTED_SHELL" != "bash" && "$DETECTED_SHELL" != "zsh" && "$DETECTED_SHELL" != "fish" ]]; then
            echo "Choose your shell for integration:"
            echo "1) bash"
            echo "2) zsh  "
            echo "3) fish"
            echo "4) skip integration"
            read -r shell_choice
            case "$shell_choice" in
                1) DETECTED_SHELL="bash" ;;
                2) DETECTED_SHELL="zsh" ;;
                3) DETECTED_SHELL="fish" ;;
                *) INSTALL_INTEGRATION=false ;;
            esac
        fi
    else
        INSTALL_INTEGRATION=false
    fi
fi

# ------------------------------------------------------------------
# 2. Prepare variables
# ------------------------------------------------------------------
REPO="sigoden/aichat"
BASE_URL="https://github.com/$REPO/releases/download/v$VERSION"

# Detect system architecture
ARCH=$(detect_architecture)
if [[ $? -ne 0 ]]; then
    exit 1
fi

# GitHub asset naming scheme (updated format includes 'v' prefix and 'unknown-linux-musl')
case "$ARCH" in
    linux-x86_64)
        ASSET_NAME="aichat-v$VERSION-x86_64-unknown-linux-musl.tar.gz"
        ;;
    linux-aarch64)
        ASSET_NAME="aichat-v$VERSION-aarch64-unknown-linux-musl.tar.gz"
        ;;
    linux-armv7)
        ASSET_NAME="aichat-v$VERSION-armv7-unknown-linux-musleabihf.tar.gz"
        ;;
    *)
        # Fallback to old naming scheme
        ASSET_NAME="aichat-$VERSION-$ARCH.tar.gz"
        ;;
esac
DOWNLOAD_URL="$BASE_URL/$ASSET_NAME"

# Target installation location
BIN_DIR="/usr/local/bin"
TARGET_BIN="$BIN_DIR/aichat"

# ------------------------------------------------------------------
# Dry-run early summary & exit (before any side effects)
# ------------------------------------------------------------------
if [[ "$AICHAT_DRY_RUN" == "1" ]]; then
    if command -v aichat >/dev/null 2>&1; then
        CURRENT_INSTALLED_VERSION=$(aichat --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo 'unknown')
    else
        CURRENT_INSTALLED_VERSION=null
    fi
    if [[ "$AICHAT_JSON" == "1" ]]; then
        # Restore original stdout (held on FD 3) so the JSON plan is emitted cleanly
        if [[ -n "${AICHAT_JSON_STDOUT_REDIRECTED:-}" ]]; then
            exec 1>&3
        fi
        # Emit JSON plan
        cat <<JSON
{
  "mode": "dry-run",
  "target_version": "${VERSION}",
        "current_version": $( if [[ "$CURRENT_INSTALLED_VERSION" == null ]]; then echo null; else echo "\"$CURRENT_INSTALLED_VERSION\""; fi ),
  "architecture": "${ARCH}",
  "download_url": "${DOWNLOAD_URL}",
  "binary_target": "${TARGET_BIN}",
  "wrapper": {"planned": $( [[ "$AICHAT_NO_WRAPPER" == "1" ]] && echo false || echo true ), "skip_reason": $( [[ "$AICHAT_NO_WRAPPER" == "1" ]] && echo '"--no-wrapper set"' || echo null )},
  "role_generator": {"planned": $( [[ "$AICHAT_SKIP_ROLE" == "1" ]] && echo false || echo true ), "skip_reason": $( [[ "$AICHAT_SKIP_ROLE" == "1" ]] && echo '"--skip-role set"' || echo null )},
  "shell": {"detected": "${DETECTED_SHELL}", "integration_planned": true},
  "completions": ["bash","zsh","fish"],
  "config": {"path": "~/.config/aichat/config.yaml", "action": "create_or_augment"},
  "backups": {"shell_rc": "on-change", "config": "on-modify"},
  "flags": {"dry_run": true, "json": true, "no_wrapper": $( [[ "$AICHAT_NO_WRAPPER" == "1" ]] && echo true || echo false ), "skip_role": $( [[ "$AICHAT_SKIP_ROLE" == "1" ]] && echo true || echo false )}
}
JSON
    else
        echo "üß™ DRY-RUN MODE (no changes will be made)" >&2
        if [[ "$CURRENT_INSTALLED_VERSION" == null ]]; then
            echo "   aichat not currently installed (target: $VERSION)" >&2
        else
            echo "   Detected existing aichat version: $CURRENT_INSTALLED_VERSION (target: $VERSION)" >&2
        fi
        echo "   Architecture: $ARCH" >&2
        echo "   Download URL: $DOWNLOAD_URL" >&2
        echo "   Binary target: $TARGET_BIN" >&2
        if [[ "$AICHAT_NO_WRAPPER" == "1" ]]; then
            echo "   Wrapper: skipped (--no-wrapper)" >&2
        else
            echo "   Wrapper strategy: move aichat -> aichat.real + create wrapper (idempotent)" >&2
        fi
        if [[ "$AICHAT_SKIP_ROLE" == "1" ]]; then
            echo "   Role generator: skipped (--skip-role)" >&2
        else
            echo "   Role generator: will install if scripts/gen-aichat-role present" >&2
        fi
        echo "   Shell detected: $DETECTED_SHELL (integration default: enabled)" >&2
        echo "   Completions planned: bash, zsh, fish (auto in dry-run)" >&2
        echo "   Config: will create or augment ~/.config/aichat/config.yaml (preludes role:local)" >&2
        echo "   Backups: shell rc & config only when modified (none created in dry-run)" >&2
        echo "   Flags: --dry-run${AICHAT_JSON:+ --json}${AICHAT_NO_WRAPPER:+ --no-wrapper}${AICHAT_SKIP_ROLE:+ --skip-role}" >&2
        echo "   To execute for real remove --dry-run or AICHAT_DRY_RUN=1" >&2
        echo "‚úÖ Dry-run completed successfully (no filesystem changes)." >&2
    fi
    exit 0
fi

# Temporary working directory (only needed for real run)
TMPDIR="$(mktemp -d -p /tmp aichat-install-XXXXXX)"

# ------------------------------------------------------------------
# 3. Check prerequisites
# ------------------------------------------------------------------
for CMD in curl tar mv chmod; do
    if ! command -v "$CMD" >/dev/null 2>&1; then
        echo "‚ùå $CMD is not installed. Please install it before running this script."
        exit 1
    fi
done

# ------------------------------------------------------------------
# 4. Download the asset (skip if binary installation not needed)
# ------------------------------------------------------------------
if [[ "$SKIP_BINARY_INSTALL" == "false" ]]; then
    echo "üì• Downloading $ASSET_NAME from GitHub ..."
    if ! curl -LfsS -o "$TMPDIR/$ASSET_NAME" "$DOWNLOAD_URL"; then
        echo "‚ùå Failed to download $DOWNLOAD_URL"
        rm -rf "$TMPDIR"
        exit 1
    fi
fi

# ------------------------------------------------------------------
# 5. Extract the binary (skip if binary installation not needed)
# ------------------------------------------------------------------
if [[ "$SKIP_BINARY_INSTALL" == "false" ]]; then
    echo "üì¶ Extracting the archive ..."
    tar -xzf "$TMPDIR/$ASSET_NAME" -C "$TMPDIR"

    # The tarball usually contains a directory named `aichat-*` with the binary inside.
    # Find the most likely location where the executable is located.
    if [[ -f "$TMPDIR/aichat" ]]; then
        EXTRACTED_BIN="$TMPDIR/aichat"
    elif [[ -f "$TMPDIR/aichat-$VERSION/aichat" ]]; then
        EXTRACTED_BIN="$TMPDIR/aichat-$VERSION/aichat"
    else
        echo "‚ùå Could not find the executable inside the archive."
        rm -rf "$TMPDIR"
        exit 1
    fi
fi

# ------------------------------------------------------------------
# 6. Install the binary (skip if binary installation not needed)
# ------------------------------------------------------------------
if [[ "$SKIP_BINARY_INSTALL" == "false" ]]; then
    echo "üöÄ Installing aichat to $TARGET_BIN ..."

    # Use sudo if necessary
    if [[ $EUID -ne 0 ]]; then
        sudo mv "$EXTRACTED_BIN" "$TARGET_BIN"
        sudo chmod 755 "$TARGET_BIN"
    else
        mv "$EXTRACTED_BIN" "$TARGET_BIN"
        chmod 755 "$TARGET_BIN"
    fi

    # Verify that the binary works
    "$TARGET_BIN" --help | head -n 3 || {
        echo "‚ùå The installed binary does not appear to work."
        rm -rf "$TMPDIR"
        exit 1
    }
fi

# ------------------------------------------------------------------
# 6.5. Install gen-aichat-role script and create wrapper
# ------------------------------------------------------------------
# Check if gen-aichat-role script exists (try both current dir and scripts subdir)
SCRIPT_DIR="$(dirname "$0")"
if [[ -f "$SCRIPT_DIR/gen-aichat-role" ]]; then
    GEN_ROLE_SCRIPT="$SCRIPT_DIR/gen-aichat-role"
elif [[ -f "$SCRIPT_DIR/scripts/gen-aichat-role" ]]; then
    GEN_ROLE_SCRIPT="$SCRIPT_DIR/scripts/gen-aichat-role"
else
    GEN_ROLE_SCRIPT=""
fi
if [[ -f "$GEN_ROLE_SCRIPT" && "$AICHAT_SKIP_ROLE" != "1" ]]; then
    echo "ÔøΩ Installing gen-aichat-role script..."
    
    # Install gen-aichat-role to /usr/local/bin
    if [[ $EUID -ne 0 ]]; then
        sudo install -m 755 "$GEN_ROLE_SCRIPT" /usr/local/bin/gen-aichat-role
    else
        install -m 755 "$GEN_ROLE_SCRIPT" /usr/local/bin/gen-aichat-role
    fi
    
    echo "‚úÖ gen-aichat-role installed to /usr/local/bin/gen-aichat-role"
    
    # Create wrapper only if we installed the binary
    if [[ "$SKIP_BINARY_INSTALL" == "false" && -f "$TARGET_BIN" && "$AICHAT_NO_WRAPPER" != "1" ]]; then
        echo "üîÑ Creating aichat wrapper with fresh role generation..."
        
        WRAPPER_CONTENT='#!/usr/bin/env bash
# aichat wrapper - ensures local role is always fresh
# Generated by install-aichat script

# Update the local role with current system context
if command -v gen-aichat-role >/dev/null 2>&1; then
    gen-aichat-role 2>/dev/null || true
fi

# Execute the actual aichat binary with all arguments
exec /usr/local/bin/aichat.real "$@"
'
        
        # Move the original aichat binary to aichat.real
        if [[ $EUID -ne 0 ]]; then
            sudo mv "$TARGET_BIN" "${TARGET_BIN}.real"
            echo "$WRAPPER_CONTENT" | sudo tee "$TARGET_BIN" > /dev/null
            sudo chmod 755 "$TARGET_BIN"
        else
            mv "$TARGET_BIN" "${TARGET_BIN}.real"
            echo "$WRAPPER_CONTENT" > "$TARGET_BIN"
            chmod 755 "$TARGET_BIN"
        fi
        
        echo "‚úÖ aichat wrapper created - local role will be refreshed on each run"
        echo "   Original binary: ${TARGET_BIN}.real"
        echo "   Wrapper script: $TARGET_BIN"
    elif [[ "$SKIP_BINARY_INSTALL" == "true" ]]; then
        echo "‚ÑπÔ∏è  Binary installation skipped - wrapper not created"
        echo "   gen-aichat-role is available at /usr/local/bin/gen-aichat-role"
        echo "   Run manually: gen-aichat-role && aichat --role local \"query\""
    fi
else
    if [[ "$AICHAT_SKIP_ROLE" == "1" ]]; then
        echo "‚ÑπÔ∏è  Skipping role generator installation (--skip-role)"
    else
        echo "‚ö†Ô∏è  gen-aichat-role script not found in current directory, skipping"
    fi
fi

# ------------------------------------------------------------------
# 7. Install shell completions (always available, independent of binary installation)
# ------------------------------------------------------------------
echo "‚öôÔ∏è  Installing shell completions..."

# Function to install completion for a specific shell
install_completion_for_shell() {
    local shell_name="$1"
    local completion_url="https://raw.githubusercontent.com/sigoden/aichat/refs/heads/main/scripts/completions/aichat.$shell_name"
    local completion_content
    
    echo "üìù Installing $shell_name completion..."
    
    # Download completion script
    if ! completion_content=$(curl -fsSL "$completion_url"); then
        echo "‚ö†Ô∏è  Failed to download $shell_name completion"
        return 1
    fi
    
    # Determine completion file location based on shell
    local completion_file
    case "$shell_name" in
        bash)
            # Try multiple locations for bash completions
            if [[ -d "/usr/share/bash-completion/completions" ]]; then
                completion_file="/usr/share/bash-completion/completions/aichat"
            elif [[ -d "/etc/bash_completion.d" ]]; then
                completion_file="/etc/bash_completion.d/aichat"
            else
                # Fallback to user-local completion
                completion_file="$HOME/.local/share/bash-completion/completions/aichat"
                # Directory will be created later in the installation process
            fi
            ;;
        zsh)
            # Try multiple locations for zsh completions (in order of preference)
            if [[ -d "/usr/share/zsh/vendor-completions" ]]; then
                completion_file="/usr/share/zsh/vendor-completions/_aichat"
            elif [[ -d "/usr/share/zsh/site-functions" ]]; then
                completion_file="/usr/share/zsh/site-functions/_aichat"
            else
                # Fallback to user-local completion
                completion_file="$HOME/.local/share/zsh/site-functions/_aichat"
                # Directory will be created later in the installation process
            fi
            ;;
        fish)
            # Fish completion location
            if [[ -d "/usr/share/fish/vendor_completions.d" ]]; then
                completion_file="/usr/share/fish/vendor_completions.d/aichat.fish"
            else
                # Fallback to user-local completion
                completion_file="$HOME/.config/fish/completions/aichat.fish"
                # Directory will be created later in the installation process
            fi
            ;;
        *)
            echo "‚ö†Ô∏è  Unknown shell: $shell_name"
            return 1
            ;;
    esac
    
    # Check if we need sudo for system-wide installation
    local use_sudo=false
    if [[ "$completion_file" == /usr/* || "$completion_file" == /etc/* ]]; then
        if [[ $EUID -ne 0 ]]; then
            use_sudo=true
        fi
    fi
    
    # Check if completion already exists
    if [[ -f "$completion_file" ]]; then
        echo "‚ÑπÔ∏è  $shell_name completion already exists at $completion_file"
        if assume_yes; then
            echo "   (auto-yes) Overwriting existing completion due to AICHAT_ASSUME_YES=1"
        else
            echo "   Do you want to overwrite it? (y/N):"
            read -r overwrite
            if [[ ! $overwrite =~ ^[Yy]$ ]]; then
                echo "‚ÑπÔ∏è  Skipping $shell_name completion"
                return 0
            fi
        fi
    fi
    
    # Ensure completion directory exists
    local completion_dir
    completion_dir="$(dirname "$completion_file")"
    
    if [[ ! -d "$completion_dir" ]]; then
        echo "üìÅ Creating completion directory: $completion_dir"
        if [[ "$use_sudo" == "true" ]]; then
            sudo mkdir -p "$completion_dir" || {
                echo "‚ùå Failed to create completion directory $completion_dir"
                return 1
            }
        else
            mkdir -p "$completion_dir" || {
                echo "‚ùå Failed to create completion directory $completion_dir"
                return 1
            }
        fi
    fi
    
    # Install the completion file
    if [[ "$use_sudo" == "true" ]]; then
        if echo "$completion_content" | sudo tee "$completion_file" > /dev/null; then
            sudo chmod 644 "$completion_file"
        else
            echo "‚ùå Failed to write $shell_name completion file"
            return 1
        fi
    else
        if echo "$completion_content" > "$completion_file"; then
            chmod 644 "$completion_file"
        else
            echo "‚ùå Failed to write $shell_name completion file"
            return 1
        fi
    fi
    
    echo "‚úÖ $shell_name completion installed at $completion_file"
    
    # Provide specific activation instructions for each shell
    case "$shell_name" in
        zsh)
            echo "   To activate: run 'autoload -U compinit && compinit' or restart your zsh session"
            ;;
        bash)
            echo "   To activate: restart your bash session or run 'source /etc/bash_completion'"
            ;;
        fish)
            echo "   To activate: restart your fish session (completions auto-load)"
            ;;
    esac
    
    return 0
}

SELECTED_COMPLETIONS=()
# Ask user which completions to install
if assume_yes; then
    completion_choice=1
    echo "(auto-yes) Installing all shell completions"
else
    echo "Which shell completions would you like to install?"
    echo "1) All shells (bash, zsh, fish)"
    echo "2) Current shell only ($DETECTED_SHELL)"
    echo "3) Choose specific shells"
    echo "4) Skip completions"
    read -r completion_choice || completion_choice=4
fi

case "$completion_choice" in
    1)
        # Install all completions
        for shell in bash zsh fish; do
            install_completion_for_shell "$shell" || echo "‚ö†Ô∏è  Failed to install $shell completion"
            SELECTED_COMPLETIONS+=("$shell")
        done
        echo "‚ÑπÔ∏è  All completions installed. Restart your shell to activate."
        ;;
    2)
        # Install for detected shell only
        if [[ "$DETECTED_SHELL" =~ ^(bash|zsh|fish)$ ]]; then
            install_completion_for_shell "$DETECTED_SHELL" || echo "‚ö†Ô∏è  Failed to install $DETECTED_SHELL completion"
            echo "‚ÑπÔ∏è  Restart your shell or run 'source ~/.${DETECTED_SHELL}rc' to activate."
            SELECTED_COMPLETIONS+=("$DETECTED_SHELL")
        else
            echo "‚ö†Ô∏è  Current shell ($DETECTED_SHELL) not supported for completions"
        fi
        ;;
    3)
        # Choose specific shells
        echo "Select shells (space-separated numbers, e.g., '1 3'):"
        echo "1) bash  2) zsh  3) fish"
        read -r shell_selection
        for choice in $shell_selection; do
            case "$choice" in
                1) install_completion_for_shell "bash"; SELECTED_COMPLETIONS+=("bash") ;;
                2) install_completion_for_shell "zsh"; SELECTED_COMPLETIONS+=("zsh") ;;
                3) install_completion_for_shell "fish"; SELECTED_COMPLETIONS+=("fish") ;;
                *) echo "‚ö†Ô∏è  Invalid choice: $choice" ;;
            esac
        done
        echo "‚ÑπÔ∏è  Selected completions installed. Restart your shells to activate."
        ;;
    *)
        echo "‚ÑπÔ∏è  Skipping shell completions installation."
        ;;
esac

# If dry-run mode was requested, stop before making changes (the real changes already skipped
# because we exit earlier; here we provide a consolidated report). To achieve true dry-run we
# must short-circuit BEFORE any side-effecting work. Therefore we implement dry-run summary and exit
# much earlier (after decision making but before downloads/install) by placing a guard further up.

# ------------------------------------------------------------------
# 8. Install shell integration (if requested)
# ------------------------------------------------------------------
if [[ "$INSTALL_INTEGRATION" == "true" && "$DETECTED_SHELL" =~ ^(bash|zsh|fish)$ ]]; then
    install_shell_integration "$DETECTED_SHELL" || {
        echo "‚ö†Ô∏è  Shell integration installation failed, but aichat binary was installed successfully."
    }
fi

# ------------------------------------------------------------------
# 9. Ensure aichat configuration directories exist
# ------------------------------------------------------------------
ensure_aichat_config_dirs || {
    echo "‚ö†Ô∏è  Failed to create aichat configuration directories"
}

# ------------------------------------------------------------------
# 10. Configure local role as default (only if gen-aichat-role was installed)
# ------------------------------------------------------------------
if [[ -f "$GEN_ROLE_SCRIPT" && "$AICHAT_SKIP_ROLE" != "1" ]]; then
    configure_local_role_default || {
        echo "‚ö†Ô∏è  Failed to configure local role as default"
    }
fi

# ------------------------------------------------------------------
# 10.5. Generate initial local role snapshot (non-root only)
# ------------------------------------------------------------------
if [[ "$AICHAT_SKIP_ROLE" != "1" && -f /usr/local/bin/gen-aichat-role && $EUID -ne 0 ]]; then
    if /usr/local/bin/gen-aichat-role >/dev/null 2>&1; then
        echo "üß© Initial local role snapshot generated"
    else
        echo "‚ö†Ô∏è  Unable to generate initial local role snapshot (will be refreshed on first aichat run)"
    fi
fi

# ------------------------------------------------------------------
# 11. Test installation
# ------------------------------------------------------------------
if [[ "$INSTALL_INTEGRATION" == "true" ]]; then
    test_shell_integration "$DETECTED_SHELL"
fi
test_completions

# ------------------------------------------------------------------
# 12. Cleanup
# ------------------------------------------------------------------
rm -rf "$TMPDIR"

if [[ "$SKIP_BINARY_INSTALL" == "false" ]]; then
    echo "‚ú® aichat $VERSION has been installed successfully!"
    echo "   Architecture: $ARCH"
    echo "   Location: $TARGET_BIN"
    if [[ -f "$GEN_ROLE_SCRIPT" ]]; then
        echo "   Wrapper: Installed (auto-refreshes local role)"
        echo "   Original binary: ${TARGET_BIN}.real"
        echo "   Role generator: /usr/local/bin/gen-aichat-role"
    fi
else
    echo "‚ú® aichat configuration completed!"
fi
if [[ "$INSTALL_INTEGRATION" == "true" ]]; then
    echo "   Shell integration: Installed for $DETECTED_SHELL"
    echo "   Usage: Press Alt+E (or Esc+E) to enhance commands with AI"
fi
if [[ -f "$GEN_ROLE_SCRIPT" && "$AICHAT_SKIP_ROLE" != "1" ]]; then
    echo "   Local role: Configured as default for CLI and REPL"
    echo "   System awareness: All commands have local system context"
fi
echo "   Configuration: Enhanced default with function calling enabled"
echo "   Config file: ~/.config/aichat/config.yaml"
if [[ "$SKIP_BINARY_INSTALL" == "false" ]]; then
    echo "   You can start it by running 'aichat' in your terminal."
    if [[ -f "$GEN_ROLE_SCRIPT" ]]; then
        echo "   Try: 'aichat \"Tell me about this system\"' (no --role needed!)"
    fi
fi
echo "   Run 'aichat --help' to see available options."

echo ""
echo "üéâ Installation complete! Happy AI-assisted command line usage!"
}

# Execute main function at the end of the script
main "$@"
